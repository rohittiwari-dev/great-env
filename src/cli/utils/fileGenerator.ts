import * as fs from "fs";
import * as path from "path";
import envReader from "../../core/envReader";
import schemaValidator from "../../core/schema";
import { EnvSchema } from "../../core/types";

/**
 * Generate TypeScript type definitions for environment variables
 */
export class EnvFileGenerator {
	/**
	 * Infer schema from environment variables
	 * @param env Environment variables
	 * @returns Inferred schema
	 */
	public inferSchema(env: Record<string, string>): EnvSchema<any> {
		const schema: EnvSchema<any> = {};

		for (const [key, value] of Object.entries(env)) {
			// Try to infer the type
			if (value === "true" || value === "false") {
				schema[key] = { type: "boolean", required: true };
			} else if (!isNaN(Number(value)) && value !== "") {
				schema[key] = { type: "number", required: true };
			} else {
				try {
					JSON.parse(value);
					schema[key] = { type: "json", required: true };
				} catch {
					schema[key] = { type: "string", required: true };
				}
			}
		}

		return schema;
	}

	/**
	 * Generate type declaration file
	 * @param outputPath Output directory
	 * @param schema Schema or undefined for auto-inference
	 */
	public generateTypeDefinitions(
		outputPath: string = "./",
		schema?: EnvSchema<any>,
	): void {
		// Read env variables for inference if no schema provided
		const env = envReader.readEnvFiles();
		const finalSchema = schema || this.inferSchema(env);

		// Generate type definitions
		const typeContent = this.generateDtsContent(finalSchema);

		// Write file
		const dtsPath = path.join(outputPath, "env.d.ts");
		fs.mkdirSync(path.dirname(dtsPath), { recursive: true });
		fs.writeFileSync(dtsPath, typeContent);

		console.log(`✅ Generated type definitions at ${dtsPath}`);
	}

	/**
	 * Generate TypeScript file with validated env
	 * @param outputPath Output directory
	 * @param schema Schema or undefined for auto-inference
	 */
	public generateEnvFile(
		outputPath: string = "./",
		schema?: EnvSchema<any>,
	): void {
		// Read env variables
		const env = envReader.readEnvFiles();
		const finalSchema = schema || this.inferSchema(env);

		// Generate content
		const tsContent = this.generateTsContent(finalSchema);

		// Determine output path
		let finalPath: string;

		if (fs.existsSync(path.join(process.cwd(), "src"))) {
			finalPath = path.join(process.cwd(), "src", "env.ts");
		} else if (fs.existsSync(path.join(process.cwd(), "app"))) {
			finalPath = path.join(process.cwd(), "app", "_env.ts");
		} else {
			finalPath = path.join(process.cwd(), "env.ts");
		}

		// Allow custom output path override
		if (outputPath !== "./") {
			finalPath = path.join(outputPath, "env.ts");
		}

		// Create directory if needed
		fs.mkdirSync(path.dirname(finalPath), { recursive: true });

		// Write file
		fs.writeFileSync(finalPath, tsContent);

		console.log(`✅ Generated env file at ${finalPath}`);
	}

	/**
	 * Generate .d.ts file content
	 * @param schema Environment schema
	 * @returns TypeScript declarations content
	 */
	private generateDtsContent(schema: EnvSchema<any>): string {
		const typeDefinition = schemaValidator.generateTypeDefinitions(schema);

		return `// Generated by mrenv
${typeDefinition}

declare global {
  namespace NodeJS {
    interface ProcessEnv extends Env {}
  }

  interface Window {
    env?: Env;
  }

  var env: Env;
}

export {};
`;
	}

	/**
	 * Generate .ts file content
	 * @param schema Environment schema
	 * @returns TypeScript content
	 */
	private generateTsContent(schema: EnvSchema<any>): string {
		return `// Generated by mrenv
import { createEnv } from 'mrenv';
${schemaValidator.generateTypeDefinitions(schema)}

// Schema for validation
const schema = ${JSON.stringify(schema, null, 2)};

// Create and validate environment
const env = createEnv({
  schema,
  onValidationError: (error) => {
    console.error('❌ Invalid environment variables:', error.message);
    process.exit(1);
  }
});

export default env;
`;
	}
}

export default new EnvFileGenerator();
