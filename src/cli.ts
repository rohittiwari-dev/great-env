// src/cli.ts
import fs from 'fs';
import path from 'path';
import {program} from 'commander';
import chalk from 'chalk';
import inquirer from 'inquirer';
import {inferType, parseEnvContent} from './utils';

import packageJson from '../package.json';

// Detect project type (Next.js, Vite, etc.)
const detectProjectType = () => {
    const cwd = process.cwd();

    if (fs.existsSync(path.join(cwd, 'next.config.js')) ||
        fs.existsSync(path.join(cwd, 'next.config.ts'))) {
        return 'nextjs';
    }

    if (fs.existsSync(path.join(cwd, 'vite.config.js')) ||
        fs.existsSync(path.join(cwd, 'vite.config.ts'))) {
        return 'vite';
    }

    if (fs.existsSync(path.join(cwd, 'angular.json'))) {
        return 'angular';
    }

    return 'generic';
};

// Find all .env files in the project
const findEnvFiles = () => {
    const cwd = process.cwd();
    const files = fs.readdirSync(cwd);
    return files.filter(file => file.startsWith('.env'));
};

// Generate type definitions for environment variables
const generateTypeDefinitions = (envVars: Record<string, string>, publicPrefix?: string) => {
    let typeDefinition = '// This file is auto-generated by SuperEnv. Do not edit manually.\n\n';

    // Main Environment interface
    typeDefinition += 'declare namespace NodeJS {\n';
    typeDefinition += '  interface ProcessEnv {\n';

    for (const [key, value] of Object.entries(envVars)) {
        const type = inferType(value);
        typeDefinition += `    ${key}: ${type};\n`;
    }

    typeDefinition += '  }\n';
    typeDefinition += '}\n\n';

    // Client-side types if publicPrefix is set
    if (publicPrefix) {
        typeDefinition += '// Client-side environment variables\n';
        typeDefinition += 'interface Window {\n';
        typeDefinition += '  env: {\n';

        for (const [key, value] of Object.entries(envVars)) {
            if (key.startsWith(publicPrefix)) {
                const type = inferType(value);
                typeDefinition += `    ${key}: ${type};\n`;
            }
        }

        typeDefinition += '  }\n';
        typeDefinition += '}\n';
    }

    return typeDefinition;
};

// Generate env.ts implementation file
const generateEnvImplementation = (envVars: Record<string, string>, options: {
    publicPrefix?: string;
    projectType: string;
    useSchema: boolean;
}) => {
    const { publicPrefix, projectType, useSchema } = options;

    let implementation = '// This file is auto-generated by SuperEnv. You can modify schema validation rules.\n';
    implementation += 'import { createEnv';

    if (useSchema) {
        implementation += ', z';
    }

    implementation += ' } from \'superenv\';\n\n';

    // Add schema if requested
    if (useSchema) {
        implementation += '// Zod schema for environment validation\n';
        implementation += 'const schema = z.object({\n';

        for (const [key, value] of Object.entries(envVars)) {
            const type = inferType(value);

            // Generate appropriate Zod validator based on inferred type
            if (type === 'boolean') {
                implementation += `  ${key}: z.enum(['true', 'false']).transform(v => v === 'true'),\n`;
            } else if (type === 'number') {
                implementation += `  ${key}: z.string().transform(Number).pipe(z.number()),\n`;
            } else {
                implementation += `  ${key}: z.string(),\n`;
            }
        }

        implementation += '});\n\n';
        implementation += '// Type inference from schema\n';
        implementation += 'type Env = z.infer<typeof schema>;\n\n';
    }

    // Generate createEnv implementation
    implementation += '// Environment configuration\n';

    if (useSchema) {
        implementation += 'export const env = createEnv<Env>({\n';
    } else {
        implementation += 'export const env = createEnv({\n';
    }

    if (publicPrefix) {
        implementation += `  publicPrefix: '${publicPrefix}',\n`;
    }

    if (useSchema) {
        implementation += '  schema,\n';
    }

    // Project-specific configurations
    if (projectType === 'nextjs') {
        implementation += '  // Next.js specific settings\n';
        implementation += '  runtime: \'auto\',\n';
    } else if (projectType === 'vite') {
        implementation += '  // Vite specific settings\n';
        implementation += '  runtime: \'auto\',\n';
    }

    implementation += '  // Error handling for validation failures\n';
    implementation += '  onValidationError: (error) => {\n';
    implementation += '    console.error(\'‚ùå Invalid environment variables:\', error.format());\n';

    if (projectType === 'nextjs') {
        implementation += '    throw new Error(\'Invalid environment configuration\');\n';
    } else {
        implementation += '    if (process.env.NODE_ENV === \'production\') {\n';
        implementation += '      throw new Error(\'Invalid environment configuration\');\n';
        implementation += '    }\n';
    }

    implementation += '  },\n';
    implementation += '  // Enable auto-reload in development\n';
    implementation += '  watch: process.env.NODE_ENV === \'development\',\n';
    implementation += '});\n';

    return implementation;
};

// Generate framework configuration
const generateFrameworkConfig = (projectType: string, publicPrefix?: string) => {
    if (projectType === 'nextjs') {
        return `// next.config.js or next.config.ts
const { withSuperEnv } = require('superenv');

module.exports = withSuperEnv({
  publicPrefix: ${publicPrefix ? `'${publicPrefix}'` : 'undefined'},
})({
  // Your Next.js configuration
});
`;
    }

    if (projectType === 'vite') {
        return `// vite.config.js or vite.config.ts
import { defineConfig } from 'vite';
import { viteSuperEnv } from 'superenv';

export default defineConfig({
  plugins: [
    viteSuperEnv({
      publicPrefix: ${publicPrefix ? `'${publicPrefix}'` : 'undefined'},
    }),
  ],
});
`;
    }

    return null;
};

// Main CLI function
export const runCLI = async () => {
    program
        .name('superenv')
        .description('SuperEnv CLI - Type-safe environment management')
        .version(packageJson.version);

    program
        .command('generate')
        .description('Generate environment type definitions and implementation')
        .option('-p, --public-prefix <prefix>', 'Prefix for public environment variables')
        .option('-o, --output <path>', 'Output path for env.ts file')
        .option('-d, --types-dir <path>', 'Output directory for type definitions')
        .option('--no-schema', 'Skip schema generation')
        .action(async (options:any) => {
            try {
                // Find all .env files
                const envFiles = findEnvFiles();

                if (envFiles.length === 0) {
                    console.log(chalk.yellow('‚ö†Ô∏è  No .env files found. Creating a sample .env file...'));

                    // Create a sample .env file
                    fs.writeFileSync('.env', `# SuperEnv sample .env file
NODE_ENV=development
PORT=3000
API_URL=http://localhost:3000/api
DEBUG=true
`);

                    console.log(chalk.green('‚úÖ Created sample .env file!'));
                    envFiles.push('.env');
                }

                console.log(chalk.blue('üìÅ Found .env files:'));
                envFiles.forEach(file => console.log(`   ${file}`));

                // Detect project type
                const projectType = detectProjectType();
                console.log(chalk.blue(`üîç Detected project type: ${projectType}`));

                // Parse .env files
                const envVars: Record<string, string> = {};

                for (const file of envFiles) {
                    const content = fs.readFileSync(file, 'utf8');
                    const vars = parseEnvContent(content);
                    Object.assign(envVars, vars);
                }

                // Check if any vars were found
                if (Object.keys(envVars).length === 0) {
                    console.log(chalk.yellow('‚ö†Ô∏è No environment variables found in .env files.'));
                    return;
                }

                console.log(chalk.blue(`üîë Found ${Object.keys(envVars).length} environment variables`));

                // Ask for public prefix if not provided
                let publicPrefix = options.publicPrefix;

                if (!publicPrefix) {
                    const answers = await inquirer.prompt([
                        {
                            type: 'confirm',
                            name: 'usePublicPrefix',
                            message: 'Do you want to use a prefix for client-side environment variables?',
                            default: true,
                        },
                        {
                            type: 'input',
                            name: 'publicPrefix',
                            message: 'Enter prefix for client-side variables:',
                            default: 'PUBLIC_',
                            when: (answers:any) => answers.usePublicPrefix,
                        },
                    ]);

                    if (answers.usePublicPrefix) {
                        publicPrefix = answers.publicPrefix;
                    }
                }

                // Generate type definitions
                const typesDir = options.typesDir || './';
                const typesDef = generateTypeDefinitions(envVars, publicPrefix);

                if (!fs.existsSync(typesDir)) {
                    fs.mkdirSync(typesDir, { recursive: true });
                }

                fs.writeFileSync(path.join(typesDir, 'env.d.ts'), typesDef);
                console.log(chalk.green(`‚úÖ Generated type definitions at ${path.join(typesDir, 'env.d.ts')}`));

                // Generate implementation file
                const useSchema = options.schema !== false;
                const implementation = generateEnvImplementation(envVars, {
                    publicPrefix,
                    projectType,
                    useSchema,
                });

                // Determine output path
                let outputPath = options.output;

                if (!outputPath) {
                    const srcDir = fs.existsSync('./src');
                    const appDir = fs.existsSync('./app');

                    const answers = await inquirer.prompt([
                        {
                            type: 'list',
                            name: 'outputPath',
                            message: 'Where do you want to save the env.ts file?',
                            choices: [
                                { name: 'Root directory (./env.ts)', value: './env.ts' },
                                ...(srcDir ? [{ name: 'src directory (./src/env.ts)', value: './src/env.ts' }] : []),
                                ...(appDir ? [{ name: 'app directory (./app/env.ts)', value: './app/env.ts' }] : []),
                                { name: 'Custom path', value: 'custom' },
                            ],
                        },
                        {
                            type: 'input',
                            name: 'customPath',
                            message: 'Enter custom path for env.ts:',
                            when: (answers:any) => answers.outputPath === 'custom',
                            validate: (input:any) => !!input || 'Path cannot be empty',
                        },
                    ]);

                    outputPath = answers.outputPath === 'custom' ? answers.customPath : answers.outputPath;
                }

                // Create directory if it doesn't exist
                const outputDir = path.dirname(outputPath);
                if (outputDir !== '.' && !fs.existsSync(outputDir)) {
                    fs.mkdirSync(outputDir, { recursive: true });
                }

                // Write implementation file
                fs.writeFileSync(outputPath, implementation);
                console.log(chalk.green(`‚úÖ Generated environment implementation at ${outputPath}`));

                // Generate framework config if needed
                const frameworkConfig = generateFrameworkConfig(projectType, publicPrefix);

                if (frameworkConfig) {
                    console.log(chalk.blue('\nüìù Framework Integration:'));
                    console.log(chalk.yellow('Add this to your framework configuration:'));
                    console.log(chalk.cyan(frameworkConfig));
                }

                console.log(chalk.green('\nüéâ SuperEnv setup complete!'));

                // Usage example
                console.log(chalk.blue('\nüìö Example Usage:'));
                console.log(chalk.cyan(`import { env } from '${outputPath.replace(/\.(ts|js)$/, '').replace(/^\.\//, '')}';

// Type-safe environment variables
console.log(env.PORT); // correctly typed as number
console.log(env.API_URL); // correctly typed as string
`));

            } catch (error) {
                console.error(chalk.red('Error generating environment files:'), error);
                process.exit(1);
            }
        });

    // Run the CLI
    program.parse(process.argv);
};

// Execute when run directly
if (require.main === module) {
    (()=>runCLI())();
}